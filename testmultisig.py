import random, os, json, sys, ast, time
from pybitcointools import *
import txpusher

def create_1_address():
    #no brainwalleting; not safe (but RNG should be considered)
    priv = sha256(str(random.randrange(2**256)))
    pub = privtopub(priv)
    addr = pubtoaddr(pub)
    return priv,pub,addr

#input must be a list of 3 public keys, format: TODO
def create_3_address(pubs):
    mscript = mk_multisig_script(pubs,2,3)
    msigaddr = scriptaddr(mscript.decode('hex'))
    return (msigaddr,mscript)

#This can be used to pay into the multisig address from a temporary
#address. The restriction is that this transaction will spend the ENTIRE
#value of that most recent unspent output at the address.
#argument 'amt' should be amount to pay PLUS txfee (just a safeguard; if
#amount+txfee does not equal existing balance, will return false.)
#amt and txfee in bitcoins, conversion to satoshis done internally
#return value is the hash of the sent transaction.
def pay_into_address(outaddr,inaddr,amt,txfee):
    amt = int(amt*1e8)
    txfee = int(txfee*1e8)
    #only 1 output, no change - keeping it as simple as poss
    outs = [{'value':amt-txfee,'address':outaddr}] 
    
    ins = history(inaddr)[0]
    
    #sanity check: the address being used here should have been 
    #(a) freshly generated and (b) funded with the appropriate amount
    if int(ins['amount']) != amt+txfee:
        print "address:",addr,"is not correctly funded; adjust amount to:",str(int((amt+txfee)/1e8)),"in bitcoins."
        print "Please note that you should be using a TEMPORARY address to pay in, generated by the app."
        print "Do NOT attempt to use one of your normal wallet addresses for this payment!"
        return False
    if ins['spend']:
        print "the funds at the address:",addr,"have already been spent, please generate another address and fund that."
        return False
    
    finaltx = mktx(ins,outs)
    txpusher.send_tx(finaltx)
    return tx_hash(temptx)

def create_escrow_tx(msigaddr,amt,txfee,addr_to_be_paid):
    amt = int(amt*1e8)
    txfee = int(txfee*1e8)
    outs = [{'value':amt-txfee,'address':addr_to_be_paid}]
     
    ins = history(msigaddr)[0]
    return mktx(history(msigaddr),outs)
    
#give all public keys and 1 private key: returns the tx with signature applied
def sign_escrow_tx(tx,mscript,priv):
    sig = multisign(temptx.decode('hex'),0,mscript.decode('hex'),priv)
    return apply_multisignatures(tx.decode('hex'),0,mscript.decode('hex'),[sig])
    
#take partially signed tx and apply second key, then send out tx on network
def finalize_and_send_escrow_payment(tx,mscript,priv):
    finaltx = sign_escrow_tx(tx,mscript,priv)
    txpusher.send_tx(finaltx)
    return tx_hash(finaltx)
                                                
#will accurately report the current confirmed and unconfirmed balance
#in the given address, and return (confirmed, unconfirmed).
#CONDITIONS: will give up if :
# *address has more than one unconfirmed transaction - this is quite possible,
# but most wallets won't spend unconfirmed coins, so we can assume normal
# users won't do this - I hope.
# *address has more than 2 transactions in the same block at any time in the past
# (this is rare)
#If the number of past transactions at the address is very large (>100), this
#function will take a LONG time - it is not fit for checking Satoshi Dice adds!
#Running time for normal addresses will usually be subsecond, but fairly
#commonly will take 5-20 seconds due to Electrum server timeouts.
def get_balance_lspnr(addr_to_test):
    
    received_btc = 0.0
    #query electrum for a list of txs at this address
    txdetails = txpusher.get_from_electrum([addr_to_test],t='a')
    x = txdetails[0]

    #need to build a list of requests to send on to electrum, asking it for
    #the raw transaction data
    args=[]
    unconfirmedtxhash = None

    for txdict in x['result']:
        if txdict["height"]==0:
            #unconfirmeds show up as block height 0
            #note: more than 1 unconfirmed is quite normal in general activity, 
            #but basically inconceivable in our multisig use case; therefore,
            #and bearing in mind the difficulty of establishing time order in this
            #special case, we will assume no more than one.
            if unconfirmedtxhash: 
                raise Exception("Unexpectedly found more than one unconfirmed\
                                 transaction for this address.")
            unconfirmedtxhash = txdict["tx_hash"]
        args.append([txdict["tx_hash"],txdict["height"]])
        
    #place transactions in order of height for correct calculation of balance
    args.sort(key=lambda x: int(x[1]))

    #in case two transactions are at the same block height, we need to reorder 
    #based on input/output relationship. First create a dict of tx hashes,
    #keyed by blockheight, to look for 2 txs with same block height
    heightsdict = {}
    for arg in args:
        if arg[1] in heightsdict.keys():
            heightsdict[arg[1]].append(arg[0])
        else:
            heightsdict[arg[1]]=[arg[0]]
        
    for k,v in heightsdict.iteritems():
        outpoints1=[]
        outpoints2=[]
        if len(v)==2:
            for i,arg in enumerate(args):
                    if v[0] == arg[0]:
                        pos1 = i
                    if v[1]==arg[0]:
                        pos2 = i
            raw1,raw2 = txpusher.get_from_electrum([args[pos1],args[pos2]],t='t')
            tx1 = deserialize(raw1['result'])
            tx2 = deserialize(raw2['result'])
            txh1 = tx_hash(raw1['result']).encode('hex')
            txh2 = tx_hash(raw2['result']).encode('hex')
            for input in tx1['ins']:
                outpoints1.append(input['outpoint']['hash'])
            for input in tx2['ins']:
                outpoints2.append(input['outpoint']['hash'])
            if txh2 in outpoints1:
                #swap 1 and 2 in args
                args[pos1:pos1+2]=reversed(args[pos1:pos1+2])
        elif len(v)>2:
            #too much additional complexity, abandoned for now
            raise Exception("Too many transactions in one block, giving up")
            break

    #unconfirmed have been sorted to the start, but should be at the end:
    if args[0][1]==0:
        unconfirmed_arg = args[0]
        args= args[1:]
        args.append(unconfirmed_arg)
        
    #we finally have a correctly ordered list of transactions to process;        
    x= txpusher.get_from_electrum(args,t='t')

    uncon_input=False
    uncon_output = 0.0
    unconfirmed_spends = 0.0
    
    #a dictionary of bitcoin amounts received, indexed by transaction hash:
    prev_outs={}

    for y in x:
        uncon=False
        rawtx = y['result']
        tx = deserialize(rawtx)
        txh = tx_hash(rawtx).encode('hex')
        if txh == unconfirmedtxhash: uncon=True
        
        for input in tx['ins']:
            pubkeys,signatures, addr = \
            txpusher.get_address_from_input_script(input['script'].decode('hex'))
    
            if not addr == addr_to_test: continue
            
            #we need to find which previous output is being spent - it must exist.
            try:
                bitcoins_being_spent = prev_outs[input['outpoint']['hash']]
            except:
                raise Exception("failed to find the reference to which\
                                 output's being spent!")
                
            if not uncon:
                received_btc -= bitcoins_being_spent 
                print "after spending, balance set to:", received_btc
            else: 
                unconfirmed_spends += bitcoins_being_spent
            
        for output in tx['outs']:
            ispubkey,addr = \
            txpusher.get_address_from_output_script(output['script'].decode('hex'))
            
            if not addr == addr_to_test: continue
            
            bitcoins =  output['value'] * 0.00000001
            
            if not uncon:
                received_btc +=bitcoins
                prev_outs[txh]=bitcoins
                
            else: 
                uncon_output = output['value'] * 0.00000001
            
    print "Final confirmed balance: ", received_btc
    #add unconfirmed balance changes last, and always input before output
    conf_bal = received_btc
    
    received_btc += uncon_output
    received_btc -= unconfirmed_spends
    print "Final balance, including unconfirmed:", received_btc
    unconf_bal = received_btc
    
    return conf_bal,unconf_bal

if __name__ == "__main__":
    
    #Test 1: check the balance of some address out there
    c,u = get_balance_lspnr(sys.argv[1])
    print "Confirmed balance for",sys.argv[1],":",str(c)
    print "Unconfirmed balance for ",sys.argv[1],":",str(u)
    
    #Test 2: make some addresses and a multisig
    privs=[]
    pubs=[]
    addresses=[]
    for i in range(1,3):
        priv,pub,addr = create_1_address()
        print "Random address created: ", addr
        privs.append(priv)
        pubs.append(pub)
        addresses.append(addr)
    msigaddr, mscript = create_3_addr(pubs)
    print "Created multisig addr:", msigaddr
    
    if (sys.argv[2]=='c'):
        #Test 3: pay into the multisig; because this needs an address
        #with a non-zero account, for convenience we'll use the same
        #address as we checked the balance on earlier
        txhash = pay_into_addr(msigaddr,sys.argv[1],0.001,0.0002)
        print "Payment into multisig sent; amount paid was .8 mbtc, transaction hash is:",txhash
        print "Wait for confirms on the network before continuing. (About 10 min)"
        exit(0)
    
    else:
        #Test 4: create the escrow transaction
        escrowtx = create_escrow_tx(msigaddr,0.0008, 0.0002,,addresses[1])
        print "Escrow transaction created:", deserialize(escrowtx)
        
        #Test 5: partially sign the escrow transaction
        escrowtx2 = sign_escrow_tx(escrowtx,mscript,privs[0])
        print "Escrow transaction partially signed:",deserialize(escrowtx2)
        
        #Test 6: finalize and send
        txhash = finalize_and_send_escrow_payment(escrowtx2,mscript,privs[1])
        print "Finished escrow unlock, transaction hash is:",txhash
        
        #Test 7: check it's been paid
        time.sleep(10)
        #should be visible by now:
        c,u = get_balance_lspnr(addresses[1])
        print "Confirmed balance at",addresses[1],"is now:",str(c)
        print "Unconfirmed balance at",addresses[1],"is now:",str(u)
    
    
    

 
#===LEGACY, for reference==============
'''
if (sys.argv[1]=='c'):
    privs = [sha256(sys.argv[2]),sha256(sys.argv[3]),sha256(sys.argv[4])]
    print "Here are the private keys: ",privs
    #in future version, 2 of these 3 pubs will be IMPORTED for addr creation
    pubs = [privtopub(priv) for priv in privs]
    print "Here are the public keys: ", pubs
    addresses = [pubtoaddr(pub) for pub in pubs]
    print "Here are the addresses generated: ",addresses

    #we make a multisig address
    mscript = mk_multisig_script(pubs,2,3)
    msigaddr = scriptaddr(mscript.decode('hex'))
    print "Multisig address created: " , msigaddr
    print "Script created: ", mscript

elif (sys.argv[1]=='r'):
    msigaddr = sys.argv[2]
    addr_to_pay = sys.argv[3]
    tx_fee = sys.argv[4] #could conceivably give change but that is not the use case of multisig
    mscript = sys.argv[5]
    priv1 = sys.argv[6]
    priv2=sys.argv[7]
    #TODO: code will ACCEPT a raw, partially signed tx and then sign it with ONE key
    #in first version of test, all keys are here
    #first CREATE a transaction FROM the multisig to the to-pay
    #address, then SIGN that transaction with 2 of the 3 keys. Then push.
    outs = [{'value':100000-int(tx_fee),'address':addr_to_pay}]
    print history(msigaddr)
    temptx = mktx(history(msigaddr),outs)
    #print tx3
    #print deserialize(tx3)
    sig1 = multisign(temptx.decode('hex'),0,mscript.decode('hex'),priv1)
    sig2 = multisign(temptx.decode('hex'),0,mscript.decode('hex'),priv2)
    finaltx = apply_multisignatures(temptx,0,mscript,[sig1,sig2])
    #as of 25 October: blockchain.info is not accepting multisig redeems
    #so we cannot call this superior method; instead we must use electrum
    #pushtx(tx4)

    #send to electrum server
    txpusher.send_tx(finaltx)
    
    print  Transaction(finaltx).hash()
    '''


